{"name":"Test for wozlla","tagline":"test_for_wozlla ","body":"# Javascript技术题：\r\n### 1. 请列举一些数组元素去重方法\r\n\r\n#### 定义新数组，正向遍历旧数组，保存旧数组中目前还未重复过的值。复杂度O(N方)\r\n\r\n    Array.prototype.unique1 = function()\r\n    {\r\n\t    var n = []; //一个新的临时数组\r\n\t    for(var i = 0; i < this.length; i++) //遍历当前数组\r\n\t    {\r\n\t\t//如果当前数组的第i已经保存进了临时数组，那么跳过，\r\n\t\t//否则把当前项push到临时数组里面\r\n\t\tif (n.indexOf(this[i]) == -1) n.push(this[i]);\r\n\t    }\r\n\t    return n;\r\n    }\r\n\r\n  \r\n\r\n#### 定义新数组和哈希，正向遍历旧数组，未重复，存入哈希和新数组，重复则continue 。复杂度0（N）\r\n\r\n\r\n\r\n     Array.prototype.unique2 = function()\r\n    {\r\n\t    var n = {},r=[]; //n为hash表，r为临时数组\r\n\t    for(var i = 0; i < this.length; i++) //遍历当前数组\r\n\t    {\r\n\t\tif (!n[this[i]]) //如果hash表中没有当前项\r\n\t\t{\r\n\t\t\tn[this[i]] = true; //存入hash表\r\n\t\t\tr.push(this[i]); //把当前数组的当前项push到临时数组里面\r\n\t\t}\r\n\t    }\r\n\t    return r;\r\n    }\r\n\r\n\r\n#### 定义新数组，旧数组先排序，遍历旧数组，不重复，push到新数组。复杂度0（N方）\r\n\r\n\r\n    Array.prototype.unique3 = function()\r\n    {\r\n\tthis.sort();\r\n\tvar re=[this[0]];\r\n\tfor(var i = 1; i < this.length; i++)\r\n\t{\r\n\t\tif( this[i] !== re[re.length-1])\r\n\t\t{\r\n\t\t\tre.push(this[i]);\r\n\t\t}\r\n\t}\r\n\treturn re;\r\n    }\r\n\r\n### 2. javascript的作用域和作用域链是什么？\r\n#### 作用域就是变量与函数的可访问范围，即作用域控制着变量与函数的可见性和生命周期。在JavaScript中，有全局作用域和局部作用域。\r\n#### 对象的属性里，函数被创建的作用域中对象的集合。比如add函数被创建时，add函数的作用域链会填入所有add函数可以访问的数据对象。这个集合就是作用域链。因为全局变量总是在作用域链尾部，如果某函数被调用的特别深，此函数调用局部变量会特别慢。避免：减少全局变量数，局部再定义全局变量。\r\n### 3. javascript变量声名提升是什么意思？\r\n#### c，c++，java是块级作用域。javascript是函数式作用域。函数运行时，把变量的声明全都提升到函数top位置。会出BUG！避免：局部变量的赋值放在函数top位置。\r\n### 4. 如何解决回调层次过深的问题？\r\n#### 给匿名函数命名，代码抛异常的时候准确定位\r\n#### 模块化\r\n### 5. Ajax是指什么？jsonP是指什么？两者的原理分别是？\r\n#### AJAX 网页异步更新，不需要刷新。\r\n#### \r\n# Canvas技术题目： \r\n### 1. 请列举十个以上常用的canvas2d的接口\r\n#### canvas.getContext('2d');获取canvas上下文\r\n#### ctx.moveTo(x,y) 起始点(x,y)\r\n#### ctx.lineTo(x,y);如果没有起始点，就是起始点；有，就是终止点\r\n#### ctx.rect(x,y,w,h)画矩形\r\n#### ctx.arc(x,y,radius,startAngle,endAngle,anticClock);圆弧\r\n#### ctx.arcTo(x1,y1,x2,y2,radius);俩点之间最短弧线\r\n#### ctx.bezierCurveTo(cp1x,cp1y,cp2x,cp2y,x,y);三次贝塞尔\r\n#### ctx.bezierCurveTo(cp1x,cp1y,x,y);两次贝塞尔\r\n#### ctx.full();闭合路径\r\n#### ctx.clip();剪切\r\n#### ctx.stroke();描边\r\n### 2. 在canvas下如何优化文字的渲染速度？\r\n#### 如果文字不怎么变，渲染到一个小canvas上保存。主canvas调用。避免重复渲染。\r\n### 3. 写下几种composite operation\r\n### 4. transform和setTransform接口的区别\r\n#### 调用 transform() 时，在前一个变换矩阵上构建\r\n#### 调用 setTransform() 时，重置前一个变换矩阵然后构建新的矩阵\r\n### 5. 请列举几个比较出名的js游戏框架\r\n#### cocos2d-js 白鹭 phaser pixi  Construct2 easeljs three.js lufylegend \r\n \r\n# WebGL技术题: \r\n### 1. 如何兼容性地获取WebGL context？\r\n      var webglContext = function(canvas) {\r\n      var names = [\"webgl\", \"experimental-webgl\", \"webkit-3d\", \"moz-webgl\"];\r\n      var context = null;\r\n      for (var ii = 0; ii < names.length; ++ii) {\r\n        try {\r\n               context = canvas.getContext(names[ii]);\r\n            } catch(e) {}\r\n        if (context) {\r\n          break;\r\n        }\r\n      }\r\n      return context;\r\n    }\r\n### 2. 列出10个常用的WebGL接口\r\n#### gl.clear(gl.COLOR_BUFFER_BIT);清空\r\n#### gl.clearColor(0.0, 0.0, 0.0, 1.0);清空画面使用的颜色\r\n#### gl.drawArrays(mode,first,count);绘制图形\r\n#### gl.createBuffer();创建缓冲区\r\n#### gl.bindBuffer();缓冲区对象绑定目标\r\n#### gl.BufferData(gl.ARRAY_BUFFER,vertices,gl.STATIC_DRAW);像缓冲区对象写入数据\r\n#### gl.vertexAttribPointer(position,2,gl.FLOAT,false,0,0);将缓冲区对象分配给position对象\r\n#### gl.enableVertexAttribArray(position);连接position变量与分配给它的缓冲区对象\r\n#### gl.deleteBuffer(buffer);删除缓冲区\r\n#### gl.deleteTexture();删除纹理对象\r\n#### gl.createTexture();创建纹理对象以存储纹理图像\r\n### 3. WebGL如何绘制图片？\r\n#### 初始化\r\n##### 1.初始化WEBGL画布\r\n##### 2.设置WEBGL状态\r\n##### 3.载入图片\r\n##### 4.利用载入的图片创建纹理\r\n##### 3,把纹理送入到WEBGL的状态机或者叫管理器,或者加工厂\r\n##### 6.设置纹理的一些选项\r\n##### 7.清空状态机\r\n##### 8.创建顶点索引缓存\r\n##### 9.创建UV缓存\r\n##### 10.创建顶点坐标缓存\r\n##### 11.创建顶点着色器\r\n##### 12.创建像素着色器\r\n#### 渲染\r\n##### 1.清空画面\r\n##### 2.上传顶点数据\r\n##### 3.上传UV数据\r\n##### 4.上传纹理\r\n##### 5.上传着色器\r\n##### 6.上传顶点索引开始绘图\r\n### 4. WebGL如何绘制文本？\r\n### 5. WebGL的pipeline是怎么样的？\r\n#### 渲染管线的处理流程开始于建立顶点数组（Vertex Array）。这些数组包括了顶点属性（例如顶点在3D空间中的位置）和顶点纹理信息、颜色信息和如何接受光照（顶点法线）。这些顶点数组和其中包含的数据都是在JavaScript中建立的，建立的方法有以下几种：\r\n####  自己编写JavaScript代码建立\r\n#### 加载并解析一个描述3D模型的文件\r\n#### 使用第三方图形库内置封装好的几何体形状\r\n#### 然后顶点数组里的数据会被填充到一个或多个顶点缓冲（Vertex Buffer）中，并传递到GPU端。在向GPU提交渲染工作的时候，我们还需要提供一个额外的数组用于描述顶点数组中元素的索引。这个顶点索引数组会在稍后控制顶点如何被装配到三角形中。\r\n\r\n#### GPU开始从顶点缓冲中读取顶点信息，并在顶点着色器（Vertex Shader）中处理这些信息。顶点着色器是一个程序，用于读取顶点属性，并输出一个新的属性集合。顶点着色器最基本的功能是计算顶点在屏幕空间中的位置。但它也会为每个顶点生成其他属性，比如颜色或纹理坐标。你可以编写代码自定义顶点着色器，也可以使用第三方图形库提供的顶点着色器。\r\n\r\n#### 然后，GPU会连接这些顶点来形成三角形。这里就用到了顶点索引数组，GPU会根据顶点索引的描述，将这些顶点按照指定顺序每3个分成一组，形成一个三角形。\r\n\r\n#### 然后光栅器（Rasterizer）会作用于每个三角形，切出这些三角形并忽略形状之外的其他部分，然后将当前剩余的可见部分打碎，填充到像素大小的片元（Fragment）中。对于其他顶点属性（比如颜色和纹理），顶点着色器会在光栅化之后的三角形表面上，为一个顶点和另一个顶点之间的部分做线性插值，为每一个片元（也就是像素）产生一个平滑的渐变值。举例来说，如果顶点着色器为每个顶点分配了一个颜色值，那么光栅器将会混合这些颜色，并在像素化的表面生成一个新的合适的渐变色。\r\n\r\n#### 这些生成的像素大小的片元之后会被传递到片元着色器（Fragment Shader）中。片元着色器将会输出每个像素的颜色和深度值，用于在帧缓冲（Frame Buffer）中进行绘制。通常情况下，片元着色器的操作包括纹理映射和光照。因为片元着色器会为每个像素进行独立绘制，这就可以实现很多相当复杂的特殊效果；但也正是因为这样，片元着色器也成为图形管线中和性能最为相关的部分。\r\n\r\n#### 最后，帧缓冲（Frame Buffer）是渲染输出的最终目的地。帧缓冲是一个2D图像，但又不仅仅是一个2D图像这么简单。除了一个或多个颜色缓冲区之外，帧缓冲还包含深度缓冲区（Depth Buffer）和/或模板缓冲区（Stencil Buffer），这两个都是在最终绘制到帧缓冲之前可选的过滤片元的方式，深度检测会忽略被前面已经绘制的物体挡住的后面的物体，模板检测会使用模板缓冲区中绘制的形状约束帧缓冲中的可绘制区域，将渲染工作“模板化”。经过这两层过滤之后依然幸存的片元，它们的颜色值会与在它们覆盖之下的颜色值进行α混合。最终的颜色值、深度值、模板值会写入相应的缓冲区。帧缓冲的输出结果也可以用作纹理输入到其他渲染中去。\r\n### 6. 着色器是什么？\r\n#### webgl绘图的关键。以字符串的形式嵌入在js文件中。分为Vertex Shader顶点着色器和Pixel Shader像素着色器两种\r\n### 7. 绘制图片时Shader里必然会用到什么内置变量？\r\n### 8. drawArray和drawElements的区别？\r\n#### drawElement可以通过缓存共用顶点。缺：额外的绘图调用。优：减少点的绘制次数。\r\n### 9. 有哪些优化WebGL性能的手段？\r\n#### 预先计算\r\n#### 规避重复渲染\r\n\r\n# 编程题：\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}